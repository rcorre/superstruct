<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Struct SuperStruct</title>
		<link rel="stylesheet" type="text/css" href="../styles/ddox.css"/>
		<link rel="stylesheet" href="../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../scripts/jquery.js">/**/</script>
		<script type="text/javascript" src="../prettify/prettify.js">/**/</script>
		<script type="text/javascript" src="../scripts/ddox.js">/**/</script>
	</head>
	<body onload="prettyPrint(); setupDdox();">
		<nav id="main-nav">
						<ul class="tree-view">
							<li>
								<a href="../superstruct.html" class="selected module">superstruct</a>
							</li>
						</ul>
				<noscript>
					<p style="color: red">The search functionality needs JavaScript enabled</p>
				</noscript>
				<div id="symbolSearchPane" style="display: none">
					<p>
						<input id="symbolSearch" type="text" placeholder="Search for symbols" onchange="performSymbolSearch(24);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
					</p>
	<ul id="symbolSearchResults" style="display: none"></ul>
	<script type="application/javascript" src="../symbols.js"></script>
	<script type="application/javascript">
var symbolSearchRootDir = "../";
$('#symbolSearchPane').show();
	</script>
				</div>
		</nav>
		<div id="main-contents">
			<h1>Struct SuperStruct</h1>
			<section>
				<p> A Variant which exposes members that are common across all <code class="prettyprint lang-d">SubTypes</code>.
</p>
<section>
<p> A <code class="prettyprint lang-d"><code class="prettyprint lang-d">SuperStruct</code>!(SubTypes...)</code> wraps an <code class="prettyprint lang-d">Algebraic!(SubTypes...)</code>.  It can
 hold a single value from any of its <code class="prettyprint lang-d">SubTypes</code>.
</p>

<p> Unlike a Variant/Algebraic, <code class="prettyprint lang-d"><code class="prettyprint lang-d">SuperStruct</code></code> exposes access to 'common' members
 that have compatible signatures.
</p>

<p> A member is 'common' if its name describes a public function or field on
 every one of <code class="prettyprint lang-d">SubTypes</code>. A call signature for a given member is 'compatible'
 if, for an instance of any one of <code class="prettyprint lang-d">SubTypes</code>, that member can be called with
 the provided set of arguments and_ all such calls have a common return type.
</p>

<p> <code class="prettyprint lang-d"><code class="prettyprint lang-d">SuperStruct</code></code> ignores members beginning with "_".
</p>
</section>

					<section>
						<h3>Templates</h3>
						<table>
							<col class="caption"/>
							<tr>
								<th>Name</th>
								<th>Description</th>
							</tr>
							<tr>
								<td>
									<a href="../superstruct/SuperStruct.this.html" class="public">
										<code>this</code>
									</a>
								</td>
								<td> Construct and populate with an initial value.
</td>
							</tr>
						</table>
					</section>
<section><h3>Example</h3>
<p>If all types have a matching field, it gets exposed:
</p>
<pre class="code prettyprint lang-d">struct Foo { int a; }
struct Bar { int a; }
auto foobar = SuperStruct!(Foo, Bar)(Foo(1));
foobar.a = 5;
assert(foobar.a == 5);
</pre>
</section>
<section><h3>Example</h3>
<p>If all types have a matching method, all compatible overloads are exposed:
</p>
<pre class="code prettyprint lang-d">struct Foo {
  int fun(int i) { return i; }
  int fun(int a, int b) { return a + b; }
}
struct Bar {
  int fun(int i) { return i; }
  int fun(int a, int b) { return a + b; }
  int fun(int a, int b, int c) { return a + b + c; }
}

auto foobar = SuperStruct!(Foo, Bar)(Foo());
assert(foobar.fun(1)    == 1);
assert(foobar.fun(1, 2) == 3);
assert(!__traits(compiles, foobar.fun(1,2,3))); // no such overload on Foo
</pre>
</section>
<section><h3>Example</h3>
<p>If a name is a field on one type and a method on another, it is exposed:
</p>
<pre class="code prettyprint lang-d">struct Foo { int a; }
struct Bar {
  private int _a;
  int a() { return _a; }
  int a(int val) { return _a = val; }
}

auto foo = SuperStruct!(Foo, Bar)(Foo());
foo.a = 5;          // sets Foo.a
assert(foo.a == 5); // gets Foo.a

auto bar = SuperStruct!(Foo, Bar)(Bar());
bar.a = 5;          // invokes Bar.a(int val)
assert(bar.a == 5); // invokes Bar.a()
</pre>
</section>

			</section>
			<section>
				<h2>Authors</h2>
<p>Ryan Roden-Corrent (<a href="https://github.com/rcorre">rcorre</a>)
</p>

			</section>
			<section>
				<h2>Copyright</h2>
<p>Â© 2015, Ryan Roden-Corrent
</p>

			</section>
			<section>
				<h2>License</h2>
<p>MIT
</p>

			</section>
		</div>
	</body>
</html>